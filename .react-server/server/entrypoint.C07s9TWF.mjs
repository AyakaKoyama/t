import{jsx as i}from"react/jsx-runtime";import{dirname as x}from"node:path";import{Suspense as T}from"react";import{g as _,z,B as $,D as R,G as S,c as u,u as M,J as j,L as N}from"./@lazarv/react-server.DjwuI6zJ.mjs";import{registerClientReference as B}from"react-server-dom-webpack/server.edge";const I=[].toSorted((e,t)=>(t.priority??0)-(e.priority??0)).map(({default:e})=>e),q=[].toSorted(([e,t],[o,d])=>(e==="*")-(o==="*")||t.split("/").length-d.split("/").length||t.localeCompare(d)),f=[["/src/app","page",null,async()=>import("./page.tsx__.8JaUaSgI.mjs"),"/home/ayaka_koyama/workspace/tech-article-app/src/app/page.tsx",async()=>import("./page.7l38tb2c.mjs").then(e=>e._)]];function y(e,t={}){if(e==="*"||t.fallback)return _(z)?null:{};const{pathname:o}=$(),d=decodeURIComponent(o);return R(e,d,t)}function H(){throw new Error("Attempted to call useErrorBoundary() from the server but useErrorBoundary is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.")}B(H,"node_modules/@lazarv/react-server/client/ErrorBoundary.jsx","useErrorBoundary");function L(){throw new Error("Attempted to call ErrorBoundary() from the server but ErrorBoundary is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.")}B(L,"node_modules/@lazarv/react-server/client/ErrorBoundary.jsx","ErrorBoundary");function G(){throw new Error("Attempted to call the default export of node_modules/@lazarv/react-server/client/ErrorBoundary.jsx from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.")}B(G,"node_modules/@lazarv/react-server/client/ErrorBoundary.jsx","default");async function U({fallback:e=null,children:t,...o}){return i(G,{...o,children:e?i(T,{fallback:e,children:t}):t})}const w=Symbol("PAGE_MATCH"),E=Symbol("PAGE_COMPONENT");async function Q(){const e=_(N);return async t=>{for(const a of I)try{const n=await a(t);if(n)return n}catch(n){e?.error(n)}let o=null,d=null;for(const[a,n,p]of q)if(o=a==="*"||a===t.request.method?y(n,{exact:!0}):null,o){d=p;break}if(d)try{u(z,o),t.request.params=o;const a=await d();return await(a[t.request.method]??a.default??(()=>{}))(t)}catch(a){e?.error(a)}const c=M();if(c&&c!=="PAGE_ROOT"){const a=f.filter(([,n,p])=>n==="page"&&p===c);for(const[n,,,,,p]of a){const g=y(n,{exact:!0});if(g){let k=f.find(([r,l,s])=>l==="error"&&s===c&&r===n)?.[5]??f.find(([r,l,s])=>l==="error"&&s===c&&y(r))?.[5]??(()=>({default:null})),C=f.find(([r,l,s])=>l==="fallback"&&s===c&&r===n)?.[5]??f.find(([r,l,s])=>l==="fallback"&&s===c&&y(r))?.[5]??(()=>({default:null})),m=f.find(([r,l,s])=>l==="loading"&&s===c&&r===n)?.[5]??f.find(([r,l,s])=>l==="loading"&&s===c&&y(r))?.[5]??(()=>({default:null}));const[{default:h,ttl:b,init$:P},{default:A},{default:O},{default:v}]=await Promise.all([p(),k(),C(),m()]);await P?.(),typeof b=="number"&&j(b),u(w,g),A?u(E,r=>i(U,{component:A,fallback:O?i(O,{}):v?i(v,{}):null,children:i(h,{...r})})):v?u(E,r=>i(T,{fallback:i(v,{}),children:i(h,{...r})})):u(E,r=>i(h,{...r}));return}}u(E,()=>null);return}for(const[a,n,p,g,k]of f){if(o=n==="page"&&!p?y(a,{exact:!0}):null,o){const{default:C,init$:m}=await g();await m?.(),u(E,C),u(w,o);break}if(o=n==="page"&&p?y(a,{exact:!0}):null,o){const[,,,C]=f.find(([,m,h,,b])=>m==="page"&&!h&&x(k).includes(x(b)))??[];if(C){const{default:m,init$:h}=await C();await h?.(),u(E,m),u(w,o);break}}}}}async function V(){let e=_(w)??null,t=_(E)??(()=>(S(404),null));return i(t,{...e})}export{V as A,Q as i,y as u};
